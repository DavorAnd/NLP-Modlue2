# -*- coding: utf-8 -*-
"""NLP Module2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FZw0fHJJhhBLDVINaKsyq_q867zAVA1W
"""

#importing datasets function to load datasets form Hugging face
from datasets import load_dataset

import pandas as pd
from datasets import load_dataset
from sklearn.feature_extraction.text import TfidfVectorizer
import spacy
from sklearn.linear_model import LogisticRegression
import streamlit as st
from sklearn.metrics import classification_report, accuracy_score

# Load the SpaCy model
nlp = spacy.load("en_core_web_md")

# Define the text preprocessing function using SpaCy
@st.cache(allow_output_mutation=True)
def spacy_preprocess(text):
    doc = nlp(text)
    # Lemmatize and lower text, and remove stop words and punctuation
    return ' '.join(token.lemma_.lower() for token in doc if not token.is_stop and not token.is_punct)

# Load dataset splits
df_train = pd.read_json('train.jsonl', lines=True)
df_test = pd.read_json('test.jsonl', lines=True)
df_validation = pd.read_json('validation.jsonl', lines=True)

# Apply SpaCy preprocessing to each split
df_train['processed_text'] = df_train['text'].apply(spacy_preprocess)
df_test['processed_text'] = df_test['text'].apply(spacy_preprocess)
df_validation['processed_text'] = df_validation['text'].apply(spacy_preprocess)

# Vectorize text using TF-IDF
tfidf = TfidfVectorizer()
X_train_tfidf = tfidf.fit_transform(df_train['processed_text'])
X_test_tfidf = tfidf.transform(df_test['processed_text'])
X_validation_tfidf = tfidf.transform(df_validation['processed_text'])

# Now we have feature matrices X_train_tfidf, X_test_tfidf, and X_validation_tfidf
# that we can use in a machine learning model along with the corresponding labels
y_train = df_train['title']
y_test = df_test['title']
y_validation = df_validation['title']



# Initialize the Logistic Regression model
logistic_model = LogisticRegression(max_iter=1000)  # Increase max_iter if the model doesn't converge

# Train the model with your training data
logistic_model.fit(X_train_tfidf, y_train)



# # Predict the labels for the validation set
# y_validation_pred = logistic_model.predict(X_validation_tfidf)

# # Evaluate the model performance
# print("Accuracy on the validation set: ", accuracy_score(y_validation, y_validation_pred))
# print(classification_report(y_validation, y_validation_pred))

@st.cache
def predict_profession(bio_text):
    # Preprocess the input text using the same steps as the training data
    processed_text = spacy_preprocess(bio_text)  # assuming preprocess_text is your preprocessing function

    # Vectorize the preprocessed text using the fitted TF-IDF vectorizer
    text_tfidf = tfidf.transform([processed_text])

    # Predict the profession using the trained logistic regression model
    profession_label = logistic_model.predict(text_tfidf)[0]

    # Return the profession label (you might want to map this to a human-readable profession name)
    return profession_label

def predict_profession(bio_text):
    # Preprocess the bio using spacy
    preprocessed_bio = spacy_preprocess(bio_text)

    # Vectorize the preprocessed bio
    vectorized_bio = tfidf.transform([preprocessed_bio])

    # Predict with the model
    prediction = logistic_model.predict(vectorized_bio)[0]
    return prediction

# Streamlit interface
st.title('Medical Professional Classifier')
st.write('Enter the bio of a medical professional to classify their profession:')

# User input
user_input = st.text_area("Bio text", "Type the bio here...", height=300)

# Button to predict profession
if st.button('Classify'):
    with st.spinner('Analyzing the bio...'):
        # Make prediction
        profession = predict_profession(user_input)
        # Display prediction
        st.success(f'The predicted profession is: {profession}')